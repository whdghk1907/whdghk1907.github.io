---
layout: single
title: "공지사항,Qna 구현"
categories: everyparking
tag: [spring, java, mysql]
toc: true
toc_label: "포스트 목차"
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
---
<br>
공지사항과 Qna의 구조와 기능에 대한 설명입니다.  
공지사항과 Qna는 가장 기본적인 게시판의 구조로써,  
댓글과 대댓글, 파일 업로드 등 기본적인 기능들로 이루어져 있습니다.  
<br>
처음 Spring과 Jsp를 공부하시는 분들에게  
유익한 정보가 많을 것으로  생각합니다.  
<br>
<hr>
<br>
# ERD 구조  
<br>
![ERD-Customer](/images/everyparking/016-ERD-Customer.jpg)  
<br>  
공지사항과 Qna는 거의 같은 구조로써,  
차이점은 찾아보기 힘들다.  
<small>*공지사항은 일반 유저가 작성이 불가능하다는 점 정도...?*</small>  
<br>
때문에 굳이 공지사항과 Qna를 구분하지 않고,  
Qna하나로 통틀어 설명하겠다.  
<br>
<hr>
<br>
# 게시글 등록  
<br>
## QnaMapper.xml  
<br>
```java
<!-- Qna 등록 (사용자 등록) -->
<insert id="insertQna" parameterType="hashMap">
	<selectKey keyProperty="QNA_SEQ" keyColumn="QNA_SEQ" resultType="INT" order="AFTER">
		SELECT MAX(QNA_SEQ) from p_qna
	</selectKey>
	INSERT INTO p_qna(
		USER_SEQ
		, SUB_CODE
		, QNA_TITLE
		, QNA_CONT
		, REG_DATE
		, MOD_SEQ
		, MOD_DATE
		, NOTE
		, USE_YN
		, QNA_COUNT
		, QNA_ANS
		, FILE_SEQ
	)
		VALUES(
		#{USER_SEQ}
		, #{SUB_CODE}
		, #{QNA_TITLE}
		, #{editorData}
		, NOW()
		, #{MOD_SEQ}
		, #{MOD_DATE}
		, #{NOTE}
		, #{USE_UN}
		, #{QNA_COUNT}
		, #{QNA_ANS}
		, #{FILE_SEQ}
	)
</insert>
```  
<br>

 |USER_SEQ|(글 작성 유저의 번호)|  
 |SUB_CODE| (유형을 분류하기 위한 공통 코드)|  
 |QNA_TITLE| (제목)|  
 |QNA_CONT| (내용)|  
 |REG_DATE| (등록 날짜)|  
 |MOD_SEQ| (글 수정 유저의 번호)|  
 |MOD_DATE| (수정 날짜)|  
 |NOTE| (참고)|  
 |USE_YN|(삭제가 아닌 Y,N으로 사용 여부 표시)|  
 |QNA_COUNT|(조회수)|  
 |QNA_ANS|(답변 여부)|
 |FILE_SEQ|(업로드할 파일 번호|  

<br>
<hr>
<br>

## QnaDao.java  
<br>
```java
public int insertQna(HashMap<String, Object> params) throws Exception;
```  
<br>
<hr>
<br>

##  QnaSevice.java
<br>
```java
public int insertQna(HttpServletRequest request, HashMap<String, Object> params) throws Exception;
```  
<br>
<hr>
<br>

## QnaServiceImpl.java

<br>

```java
@Override
public int insertQna(HttpServletRequest request, HashMap<String, Object> params) throws Exception {
	
    List<Integer> file_seq = fileService.uploadFile(request, filePath);
    if(file_seq != null){
        params.put("FILE_SEQ", file_seq.get(0));
    }		   
    qnadao.insertQna(params);
    
return 1;
}
```  
<br>

파일 업로드를 위하여 fileservice를 Autowired 해왔다.  
fileservice에서 파일 등록이 이루어지고, file_seq가 존재한다면  
등록할 param 배열에 FILE_SEQ를 추가해준다.  

<br>
<hr>
<br>


## RestQnaController.java  

<br>

```java
@RequestMapping("/insertQna")
public ModelAndView insertQna(HttpServletRequest request
		, @RequestParam HashMap<String, Object> params
		) throws Exception{
	ModelAndView mav = super.createMav();
	try {
		SessionUtil.setCreator(request, params);
		mav = super.createMav(qnaservice.insertQna(request, params));
		super.setMessage(mav, Ajax.SAVE.TEXT+"."+Ajax.TYPE_SUCCESS);
	} catch (Exception e) {
		logger.error(e.getMessage());
		super.setMessage(mav, Ajax.SAVE.TEXT+"."+Ajax.TYPE_FAIL);
	}
	mav.setViewName("redirect:/operation/QNA/list");
	return mav;
}
```  
<br>
프로젝트에 공통으로 사용되는 코드들이 많이 들어있지만,  
setMessage나 error등은 단순 메세지 전달용이다.  
핵심은, request에 유저 정보를 담고, params에  
게시글의 정보를 담아서 mav에 정리한뒤, mav를 리턴하여  
통신한다는 점이다.  
<br>
<hr>
<br>

## write.jsp

```jsp
<form action="/operation/QNA/insertQna" method="post" enctype="multipart/form-data" onsubmit="uploadData()">
	<input type="hidden" name="editorData">
    <div class="row buyDetailLineBox">
        <div class="col my-2 py-2">
            <div class="row py-2">
                <div class="col sectionName">문의 유형</div>
            </div>
            <div class="row pt-2">
                <div>
                    <select id="type" name="SUB_CODE" class="form-select formFontSize" aria-label="Default select example">
                        <option selected>문의 유형을 선택해주세요.</option>
                        <option value="QN01">사이트 문의</option>
                        <option value="QN02">예약 문의</option>
                        <option value="QN03">주차장 정보 문의</option>
                        <option value="QN04">기타 관련</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    <div class="row py-2">
        <div class="col my-2 sectionName">문의 내용</div>
    </div>
    <div class="row pt-1">
        <div class="col">
            <input name="QNA_TITLE" type="text" class="form-control formFontSize" placeholder="문의 제목을 입력해주세요.">
        </div>
    </div>
    <div class="row py-3">
        <div class="col">
            <textarea id="writeEditor" placeholder="문의할 내용을 입력해주세요."></textarea>
        </div>
    </div>
    <div class="row">
        <div class="col">
			<input type="file" name="FILE_SEQ" id="files">                      
        </div>
    </div>
    <div class="row pt-4">
        <div class="col">
        	<button class="cancelBtn" onclick="history.back();">취소</button>
            <button type="submit" class="longBtn">등록</button>
        </div>
    </div>
</form>
```  
<br>
전체 JSP가 아닌, Form 부분만을 가져왔다.  
이 당시 나의 미숙함으로 인해 JSP의 내용이 너무 난잡한 이유도 있고,  
포스팅의 목적이 디자인이 아닌 데이터의 전달에 있기 때문이다.  
form 자체만 보아서는 데이터의 전달을 완벽히 이해하기 힘들다.  
JavaScript까지 함께 관찰한 후 이야기하자.  
<br>
<hr>
<br>

## qnaManage.js   

<br>

```javascript
function uploadData() {
	
	let editorData = editor.getData();
	$('input[name=editorData]').val(editorData);
	
	var typeData = document.getElementById("type");

	var type = typeData.options[typeData.selectedIndex].value;
	
	let qnaTitle = document.getElementsByName("QNA_TITLE")[0].value;
	
	if ( editorData==null || editorData=="" ) {
		cmm.alert("본문을 입력해 주세요");
		event.preventDefault();
		return false; 
	}
		
	if ( qnaTitle==null || qnaTitle=="" ) {
		cmm.alert("제목을 입력해 주세요");
		event.preventDefault();
		return false;
	}
	
	if ( type == "" || type == "문의 유형을 선택해주세요." || type == null) {
		cmm.alert("올바른 유형을 선택해 주세요");
		event.preventDefault();
		return false;
	}
}
```  
<br>
갑작스런 editor의 등장에 당황하지 말자.  
개발환경을 세팅할 때, 공통된 JS파일에(commonRun.js)   
Jsp 안에 id가 writeEditor인 구문이 있으면,  
그 위치에 Ckeditor가 등장하고,  
Ckeditor가 editor로 되게끔 정의해 놓았다.  
<br>
즉, Ckeditor에 담긴 데이터를 editorData라는 변수로 옮긴 후,  
그 데이터를 다시 editorDate라는 name을 가진 input에 넣어 전달한다.  
때문에 Jsp파일에 hidden으로 숨긴 editorData가 존재한다.  
<br>
유효성 검사가 필요한 데이터는 JavaScript가 수집하여,  
유효성 검사를 진행한 후에 데이터를 통신한다.  
조건문은, 데이터가 적합하지 않은 경우 작동한다.  
event.preventDefault();는 하던 작업을 중단시키고,  
return false;는 false를 반환하여 통신을 중단시킨다.  
<br>
<hr>
<br>

#게시글 수정